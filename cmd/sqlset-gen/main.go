// cmd/sqlset-gen/main.go

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/istovpets/sqlset"
)

func main() {
	dir := flag.String("dir", "queries", "directory with .sql files (relative to current working directory)")
	out := flag.String("out", "queries/constants.go", "output file path")
	pkg := flag.String("pkg", "queries", "package name for the generated file")
	flag.Parse()

	fsys := os.DirFS(*dir)

	sqlSet, err := sqlset.New(fsys)
	if err != nil {
		log.Fatalf("failed to load sqlset from %q: %v", *dir, err)
	}

	generated, err := GenerateConstants(sqlSet, *pkg)
	if err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile(*out, []byte(generated), 0644); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated: %s (based on %d sets)\n", *out, len(sqlSet.GetSetsMetas()))
}

func GenerateConstants(sqlSet *sqlset.SQLSet, pkgName string) (string, error) {
	var setIDs []string
	for _, meta := range sqlSet.GetSetsMetas() {
		if meta.ID != "" {
			setIDs = append(setIDs, meta.ID)
		}
	}
	sort.Strings(setIDs)

	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	sb.WriteString("// Code generated by sqlset-gen. DO NOT EDIT.\n\n")
	sb.WriteString("const (\n")

	for _, setID := range setIDs {
		queryIDs, err := sqlSet.GetQueryIDs(setID)
		if err != nil {
			return "", fmt.Errorf("getting queries for %q: %w", setID, err)
		}
		if len(queryIDs) == 0 {
			continue
		}

		sort.Strings(queryIDs)

		sb.WriteString(fmt.Sprintf("\t// %s.sql\n", setID))

		for _, qID := range queryIDs {
			constName := toCamel(setID) + toCamel(qID)
			fullPath := setID + "." + qID
			sb.WriteString(fmt.Sprintf("\t%s = %q\n", constName, fullPath))
		}

		sb.WriteString("\n")
	}

	sb.WriteString(")\n")

	return sb.String(), nil
}

// toCamel converts snake_case or kebab-case to CamelCase
func toCamel(s string) string {
	s = strings.ReplaceAll(s, "-", " ")
	s = strings.ReplaceAll(s, "_", " ")
	parts := strings.Fields(s)

	var b strings.Builder
	for _, p := range parts {
		if p == "" {
			continue
		}
		b.WriteString(strings.ToUpper(p[:1]))
		b.WriteString(p[1:])
	}

	return b.String()
}
